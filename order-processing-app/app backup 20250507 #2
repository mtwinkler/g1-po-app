# app.py - Cleaned and Updated (Fixing packing slip args v7)

import os
import time # For PO Number generation
import traceback # For detailed error logging in development
from flask import Flask, jsonify, request
import sqlalchemy
from sqlalchemy import text # For sqlalchemy.text for raw SQL / transaction control
from dotenv import load_dotenv
from google.cloud.sql.connector import Connector as GcpSqlConnector # Alias connector
import requests
from datetime import datetime, timezone # For po_date
# from sqlalchemy.dialects.postgresql import insert # Not currently used, can remove if unused elsewhere
from decimal import Decimal # If you need to handle decimal conversion for total_amount explicitly
# import re # Not needed for numeric PO numbers
import inspect # For checking function arguments if needed

# --- Import your custom service modules ---
# Ensure these files exist and are accessible
try:
    import document_generator
except ImportError as e:
    print(f"WARN: Could not import document_generator: {e}")
    document_generator = None # Set to None to allow app to start, but document generation will fail

try:
    import shipping_service
except ImportError as e:
    print(f"WARN: Could not import shipping_service: {e}")
    shipping_service = None # Set to None, shipping/BC updates will fail
# --- End Service Imports ---


# Load environment variables from .env file
load_dotenv()

app = Flask(__name__)
app.debug = os.getenv("FLASK_DEBUG", "False").lower() == "true"

# --- Configuration ---
db_connection_name = os.getenv("DB_CONNECTION_NAME")
db_user = os.getenv("DB_USER")
db_password = os.getenv("DB_PASSWORD")
db_name = os.getenv("DB_NAME")
db_driver = os.getenv("DB_DRIVER", "pg8000") # Default to pg8000

bc_store_hash = os.getenv("BIGCOMMERCE_STORE_HASH")
bc_client_id = os.getenv("BIGCOMMERCE_CLIENT_ID") # Needed? Check usage
bc_access_token = os.getenv("BIGCOMMERCE_ACCESS_TOKEN")
domestic_country_code = os.getenv("DOMESTIC_COUNTRY_CODE", "US")
bc_processing_status_id = os.getenv("BC_PROCESSING_STATUS_ID")
bc_shipped_status_id = os.getenv("BC_SHIPPED_STATUS_ID")

# BigCommerce API Setup
bc_api_base_url_v2 = None
bc_headers = None
if bc_store_hash and bc_access_token:
    bc_api_base_url_v2 = f"https://api.bigcommerce.com/stores/{bc_store_hash}/v2/"
    bc_headers = {
        "X-Auth-Token": bc_access_token,
        "Content-Type": "application/json",
        "Accept": "application/json"
        # "X-Auth-Client": bc_client_id, # Usually not needed for V2 token auth
    }
else:
    print("WARN APP_SETUP: BigCommerce API credentials not fully configured.")

# --- Database Connection Pool Initialization ---
engine = None
gcp_connector_instance = None
try:
    if not all([db_connection_name, db_user, db_password, db_name]):
        print("ERROR APP_SETUP: Missing one or more database connection environment variables.")
    else:
        print(f"DEBUG APP_SETUP: Initializing DB connection for {db_connection_name} using {db_driver}")
        gcp_connector_instance = GcpSqlConnector()

        def getconn(): # Closure to capture connector instance and credentials
            conn_gcp = gcp_connector_instance.connect(
                db_connection_name,
                db_driver,
                user=db_user,
                password=db_password,
                db=db_name
            )
            return conn_gcp

        engine = sqlalchemy.create_engine(
            f"postgresql+{db_driver}://", # DSN format for creator
            creator=getconn,
            pool_size=5,
            max_overflow=2,
            pool_timeout=30,
            pool_recycle=1800, # Recycle connections every 30 minutes
            echo=False # Set to True for verbose SQL logging if needed
        )
        print("DEBUG APP_SETUP: Database engine initialized successfully.")

except ImportError:
    print("ERROR APP_SETUP: google-cloud-sql-connector library not found. Please install it (`pip install google-cloud-sql-connector[pg8000]`).")
except Exception as e_engine:
    print(f"CRITICAL APP_SETUP: Database engine initialization failed: {e_engine}")
    traceback.print_exc()
    engine = None # Ensure engine is None if setup fails
# --- End DB Setup ---


# === HELPER FUNCTIONS (Optional) ===
def convert_row_to_dict(row):
    """Converts a SQLAlchemy Row object to a dictionary, handling Decimal and Datetime."""
    if not row:
        return None
    # Use _asdict() for Row objects, or _mapping for older RowProxy if needed
    row_dict = row._asdict() if hasattr(row, '_asdict') else dict(getattr(row, '_mapping', {}))

    # Ensure keys are strings if needed (less common now but safe)
    row_dict = {str(k): v for k, v in row_dict.items()}

    for key, value in row_dict.items():
        if isinstance(value, Decimal):
            # Keep Decimal for internal use, convert only for JSON output
            row_dict[key] = value
        elif isinstance(value, datetime):
            # Ensure datetime is timezone-aware (assuming UTC from DB or setting it)
            if value.tzinfo is None:
                 value = value.replace(tzinfo=timezone.utc)
            # Keep original datetime object for potential internal use
            row_dict[key] = value # Keep as datetime object
    return row_dict

# === BASIC ROUTES ===
@app.route('/')
def hello():
    return 'G1 PO App Backend is Running!'

@app.route('/test_db')
def test_db_connection():
    if engine is None:
        return jsonify({"message": "DB engine not initialized"}), 500
    conn = None
    try:
        conn = engine.connect()
        result = conn.execute(sqlalchemy.text("SELECT 1")).scalar_one_or_none()
        conn.close() # Close connection after use
        if result == 1:
            return jsonify({"message": "DB connection successful!"})
        return jsonify({"message": "Unexpected DB result"}), 500
    except Exception as e:
        print(f"ERROR /test_db: {e}")
        traceback.print_exc()
        # Ensure connection is closed even on error if it was opened
        if conn and not conn.closed: conn.close()
        return jsonify({"message": f"DB query failed: {e}"}), 500
    # No finally needed here as conn.close() is called in try/except


# === ORDER ROUTES ===

# --- GET List Orders ---
@app.route('/api/orders', methods=['GET'])
def list_orders():
    print("Received request for GET /api/orders")
    if engine is None: return jsonify({"error": "Database engine not initialized."}), 500
    conn = None
    try:
        conn = engine.connect()
        status_filter = request.args.get('status')
        is_international_filter = request.args.get('international') # String 'true'/'false'

        # Start building query using SQLAlchemy text for safety with parameters
        base_query = "SELECT * FROM orders WHERE 1=1"
        params = {}
        conditions = []

        if status_filter:
            conditions.append("status = :status")
            params["status"] = status_filter
        if is_international_filter is not None: # Check if param exists
            conditions.append("is_international = :is_international")
            params["is_international"] = is_international_filter.lower() == "true"

        if conditions:
            base_query += " AND " + " AND ".join(conditions)

        base_query += " ORDER BY order_date DESC" # Add ordering

        query_sql = text(base_query)
        result = conn.execute(query_sql, params)
        # Convert for JSON output AFTER fetching
        orders_raw = [convert_row_to_dict(row) for row in result]
        orders_json_safe = []
        for order in orders_raw:
             # Convert datetime/decimal to ISO string/string for JSON compatibility
             order_json = order.copy()
             for key, value in order_json.items():
                  if isinstance(value, datetime):
                       order_json[key] = value.isoformat()
                  elif isinstance(value, Decimal):
                       order_json[key] = str(value)
             orders_json_safe.append(order_json)


        print(f"DEBUG LIST_ORDERS: Found {len(orders_json_safe)} orders matching criteria.")
        return jsonify(orders_json_safe)

    except Exception as e:
        print(f"ERROR LIST_ORDERS: {e}")
        traceback.print_exc()
        return jsonify({"error": "Failed to fetch orders", "details": str(e)}), 500
    finally:
        if conn:
            if not conn.closed: conn.close()
            print("DEBUG LIST_ORDERS: Database connection closed.")


# --- GET Single Order Details ---
@app.route('/api/orders/<int:order_id>', methods=['GET'])
def get_order_details(order_id):
    """Fetches details for a single order and its line items from the local DB."""
    print(f"DEBUG GET_ORDER: Received request for order ID: {order_id}")
    db_conn = None
    try:
        if engine is None: return jsonify({"error": "Database engine not available."}), 500
        db_conn = engine.connect()
        print(f"DEBUG GET_ORDER: DB connection established.")

        # Fetch Main Order Data
        order_query = text("SELECT * FROM orders WHERE id = :order_id")
        order_record = db_conn.execute(order_query, {"order_id": order_id}).fetchone()
        if not order_record: return jsonify({"error": f"Order with ID {order_id} not found"}), 404
        order_data_dict = convert_row_to_dict(order_record) # Keeps datetime/decimal objects

        # Fetch Order Line Items
        order_line_items_query = text("SELECT * FROM order_line_items WHERE order_id = :order_id ORDER BY id")
        local_order_line_items_records = db_conn.execute(order_line_items_query, {"order_id": order_id}).fetchall()
        line_items_list = [convert_row_to_dict(row) for row in local_order_line_items_records] # Keeps datetime/decimal objects
        print(f"DEBUG GET_ORDER: Found order ID {order_id} with {len(line_items_list)} line items.")

        # --- Convert datetimes/decimals to strings specifically for JSON output ---
        order_data_json_safe = order_data_dict.copy()
        for key, value in order_data_json_safe.items():
             if isinstance(value, datetime):
                  order_data_json_safe[key] = value.isoformat()
             elif isinstance(value, Decimal):
                 order_data_json_safe[key] = str(value)

        line_items_json_safe = []
        for item in line_items_list:
             item_safe = item.copy()
             for key, value in item_safe.items():
                  if isinstance(value, datetime):
                       item_safe[key] = value.isoformat()
                  elif isinstance(value, Decimal):
                       item_safe[key] = str(value)
             line_items_json_safe.append(item_safe)
        # --- End JSON conversion ---

        response_data = {"order": order_data_json_safe, "line_items": line_items_json_safe}
        return jsonify(response_data), 200

    except Exception as e:
        original_error_traceback = traceback.format_exc()
        print(f"ERROR GET_ORDER: Error fetching order {order_id}: {e}")
        print("--- ORIGINAL ERROR TRACEBACK ---")
        print(original_error_traceback)
        print("--- END ORIGINAL ERROR TRACEBACK ---")
        return jsonify({"error": "An unexpected error occurred while fetching order details.", "details": str(e)}), 500
    finally:
        if db_conn:
            if not db_conn.closed: db_conn.close()
            print(f"DEBUG GET_ORDER: Database connection closed for ID {order_id}.")


# --- POST Ingest Orders ---
# (Assuming this logic is correct as per previous iterations)
@app.route('/ingest_orders', methods=['POST'])
def ingest_orders():
    print("Received request for /ingest_orders")
    if not bc_api_base_url_v2 or not bc_headers: return jsonify({"error": "BigCommerce API credentials not fully configured."}), 500
    if engine is None: return jsonify({"error": "Database engine not initialized."}), 500

    try:
        target_status_id = int(bc_processing_status_id)
    except (ValueError, TypeError):
        return jsonify({"error": f"BC_PROCESSING_STATUS_ID '{bc_processing_status_id}' is not valid."}), 500

    conn = None
    trans = None
    ingested_count = 0
    inserted_count_this_run = 0
    updated_count_this_run = 0

    try:
        orders_list_endpoint = f"{bc_api_base_url_v2}orders"
        api_params = {'status_id': target_status_id, 'sort': 'date_created:asc', 'limit': 250}
        print(f"DEBUG INGEST: Calling BC API: {orders_list_endpoint} with status_id={target_status_id}")
        response = requests.get(orders_list_endpoint, headers=bc_headers, params=api_params)
        response.raise_for_status()
        orders_list = response.json()

        if not isinstance(orders_list, list):
            print(f"ERROR INGEST: BC API response was not a list. Type: {type(orders_list)}")
            return jsonify({"error": "Unexpected API response format from BigCommerce."}), 500

        print(f"DEBUG INGEST: Received {len(orders_list)} orders from BigCommerce.")
        if not orders_list:
            return jsonify({"message": f"Successfully processed 0 orders (none found with status ID {target_status_id})."}), 200

        conn = engine.connect()
        trans = conn.begin()

        for bc_order_summary in orders_list:
            order_id = bc_order_summary.get('id')
            if not order_id or not isinstance(bc_order_summary, dict): continue
            print(f"\nDEBUG INGEST: Processing BC Order ID: {order_id}")
            ingested_count += 1

            shipping_address_list, products_list = [], []
            customer_shipping_address, is_international, calculated_shipping_method_name = {}, False, 'N/A'
            try:
                shipping_addr_url = f"{bc_api_base_url_v2}orders/{order_id}/shippingaddresses"
                shipping_resp = requests.get(shipping_addr_url, headers=bc_headers)
                shipping_resp.raise_for_status()
                shipping_address_list = shipping_resp.json()
                if shipping_address_list and isinstance(shipping_address_list, list) and shipping_address_list[0]:
                    customer_shipping_address = shipping_address_list[0]
                    shipping_country_code = customer_shipping_address.get('country_iso2')
                    is_international = shipping_country_code != domestic_country_code
                    calculated_shipping_method_name = customer_shipping_address.get('shipping_method', 'N/A')
                else:
                    print(f"WARN INGEST: No valid shipping address found for BC Order {order_id}. Skipping.")
                    continue

                products_url = f"{bc_api_base_url_v2}orders/{order_id}/products"
                products_resp = requests.get(products_url, headers=bc_headers)
                products_resp.raise_for_status()
                products_list = products_resp.json()
                if not isinstance(products_list, list): products_list = []
                print(f"DEBUG INGEST: Fetched {len(products_list)} products for BC Order {order_id}.")

            except requests.exceptions.RequestException as sub_e:
                print(f"ERROR INGEST: Failed to fetch sub-resources for BC Order {order_id}: {sub_e}. Skipping.")
                continue

            existing_order_query = text("SELECT id, status, is_international FROM orders WHERE bigcommerce_order_id = :bc_order_id")
            existing_order = conn.execute(existing_order_query, {"bc_order_id": order_id}).fetchone()
            target_app_status = 'international_manual' if is_international else 'new'

            if existing_order:
                needs_update = (existing_order.status != target_app_status or existing_order.is_international != is_international)
                if needs_update:
                    update_stmt = text("UPDATE orders SET status = :status, is_international = :is_international, updated_at = :now WHERE id = :id")
                    conn.execute(update_stmt, {"status": target_app_status, "is_international": is_international, "now": datetime.now(timezone.utc), "id": existing_order.id})
                    updated_count_this_run += 1
                    print(f"DEBUG INGEST: Updated existing Order {order_id} (App ID: {existing_order.id})")
            else:
                try: order_date_parsed = datetime.strptime(bc_order_summary['date_created'], '%a, %d %b %Y %H:%M:%S %z').replace(tzinfo=timezone.utc)
                except (KeyError, ValueError): order_date_parsed = datetime.now(timezone.utc)

                insert_order_sql = text("""
                    INSERT INTO orders (bigcommerce_order_id, customer_name, customer_shipping_address_line1, customer_shipping_address_line2, customer_shipping_city, customer_shipping_state, customer_shipping_zip, customer_shipping_country, customer_phone, customer_email, customer_shipping_method, customer_notes, order_date, total_sale_price, status, is_international, created_at, updated_at)
                    VALUES (:bc_id, :name, :addr1, :addr2, :city, :state, :zip, :country, :phone, :email, :method, :notes, :date, :total, :status, :intl, :now, :now) RETURNING id
                """)
                order_params = {
                    "bc_id": order_id, "name": f"{customer_shipping_address.get('first_name', '')} {customer_shipping_address.get('last_name', '')}".strip(),
                    "addr1": customer_shipping_address.get('street_1'), "addr2": customer_shipping_address.get('street_2'),
                    "city": customer_shipping_address.get('city'), "state": customer_shipping_address.get('state'),
                    "zip": customer_shipping_address.get('zip'), "country": customer_shipping_address.get('country_iso2'),
                    "phone": customer_shipping_address.get('phone'), "email": bc_order_summary.get('billing_address', {}).get('email'),
                    "method": calculated_shipping_method_name, "notes": bc_order_summary.get('customer_message'),
                    "date": order_date_parsed, "total": Decimal(bc_order_summary.get('total_inc_tax', '0.00')),
                    "status": target_app_status, "intl": is_international, "now": datetime.now(timezone.utc)
                }
                result_order_insert = conn.execute(insert_order_sql, order_params)
                inserted_order_id = result_order_insert.scalar_one_or_none()

                if inserted_order_id is None: continue # Skip line items if failed
                inserted_count_this_run += 1
                print(f"DEBUG INGEST: Inserted new Order {order_id} with app ID {inserted_order_id}")

                if products_list:
                    insert_item_sql = text("""INSERT INTO order_line_items (order_id, bigcommerce_line_item_id, sku, name, quantity, sale_price, created_at, updated_at) VALUES (:order_id, :bc_li_id, :sku, :name, :qty, :price, :now, :now)""")
                    for item in products_list:
                        if not isinstance(item, dict): continue
                        item_params = {"order_id": inserted_order_id, "bc_li_id": item.get('id'), "sku": item.get('sku'), "name": item.get('name'), "qty": item.get('quantity'), "price": Decimal(item.get('price_inc_tax', '0.00')), "now": datetime.now(timezone.utc)}
                        conn.execute(insert_item_sql, item_params)
                    print(f"DEBUG INGEST: Inserted {len(products_list)} line items for app order ID {inserted_order_id}.")

        trans.commit()
        print("DEBUG INGEST: Transaction committed.")
        return jsonify({"message": f"Ingestion complete. Processed {ingested_count} orders. Inserted: {inserted_count_this_run}, Updated: {updated_count_this_run}."}), 200

    except requests.exceptions.RequestException as req_e:
        print(f"ERROR INGEST: BigCommerce API Request failed: {req_e}")
        if conn and trans and trans.is_active: trans.rollback()
        traceback.print_exc()
        status_code = req_e.response.status_code if req_e.response is not None else 500
        return jsonify({"error": "BigCommerce API request failed", "details": str(req_e)}), status_code
    except Exception as e:
        print(f"ERROR INGEST: Unexpected error: {e}")
        if conn and trans and trans.is_active: trans.rollback()
        traceback.print_exc()
        return jsonify({"error": "An unexpected error occurred during ingestion.", "details": str(e)}), 500
    finally:
        if conn:
             if not conn.closed: conn.close()
             print("DEBUG INGEST: Database connection closed.")


# === SUPPLIER CRUD ROUTES ===
# (Assuming these are correct as provided)
@app.route('/api/suppliers', methods=['POST'])
def create_supplier():
    print("Received request for POST /api/suppliers")
    if engine is None: return jsonify({"error": "Database engine not initialized."}), 500
    conn = None; trans = None
    try:
        supplier_data = request.json
        if not supplier_data or not supplier_data.get('name') or not supplier_data.get('email'):
            return jsonify({"error": "Missing required fields: name and email"}), 400
        conn = engine.connect(); trans = conn.begin()
        insert_sql = text("""INSERT INTO suppliers (name, email, payment_terms, address_line1, address_line2, city, state, zip, country, phone, contact_person, created_at, updated_at) VALUES (:name, :email, :payment_terms, :addr1, :addr2, :city, :state, :zip, :country, :phone, :contact, :now, :now) RETURNING id""")
        params = {"name": supplier_data.get('name'), "email": supplier_data.get('email'), "payment_terms": supplier_data.get('payment_terms'), "addr1": supplier_data.get('address_line1'), "addr2": supplier_data.get('address_line2'), "city": supplier_data.get('city'), "state": supplier_data.get('state'), "zip": supplier_data.get('zip'), "country": supplier_data.get('country'), "phone": supplier_data.get('phone'), "contact": supplier_data.get('contact_person'), "now": datetime.now(timezone.utc)}
        result = conn.execute(insert_sql, params)
        inserted_supplier_id = result.scalar_one_or_none()
        if inserted_supplier_id is None: raise Exception("Failed to get new supplier ID.")
        trans.commit()
        print(f"DEBUG CREATE_SUPPLIER: Inserted supplier ID: {inserted_supplier_id}")
        return jsonify({"message": "Supplier created successfully", "supplier_id": inserted_supplier_id}), 201
    except sqlalchemy.exc.IntegrityError as e:
        if trans and trans.is_active: trans.rollback()
        print(f"ERROR CREATE_SUPPLIER: Integrity Error: {e}")
        return jsonify({"error": "Supplier creation failed: Duplicate entry."}), 409
    except Exception as e:
        if trans and trans.is_active: trans.rollback()
        print(f"ERROR CREATE_SUPPLIER: Unexpected error: {e}"); traceback.print_exc()
        return jsonify({"error": "Supplier creation failed.", "details": str(e)}), 500
    finally:
        if conn and not conn.closed: conn.close()
        print("DEBUG CREATE_SUPPLIER: Database connection closed.")

@app.route('/api/suppliers', methods=['GET'])
def list_suppliers():
    print("Received request for GET /api/suppliers")
    if engine is None: return jsonify({"error": "Database engine not initialized."}), 500
    conn = None
    try:
        conn = engine.connect()
        query = text("SELECT * FROM suppliers ORDER BY name")
        result = conn.execute(query)
        suppliers_raw = [convert_row_to_dict(row) for row in result]
        suppliers_json_safe = []
        for supplier in suppliers_raw:
             supplier_json = supplier.copy() # Work on a copy
             for key, value in supplier_json.items():
                  if isinstance(value, datetime):
                       supplier_json[key] = value.isoformat()
                  elif isinstance(value, Decimal): # Added Decimal check
                       supplier_json[key] = str(value)
             suppliers_json_safe.append(supplier_json)
        print(f"DEBUG LIST_SUPPLIERS: Found {len(suppliers_json_safe)} suppliers.")
        return jsonify(suppliers_json_safe)
    except Exception as e:
        print(f"ERROR LIST_SUPPLIERS: {e}"); traceback.print_exc()
        return jsonify({"error": "Failed to fetch suppliers", "details": str(e)}), 500
    finally:
        if conn and not conn.closed: conn.close()
        print("DEBUG LIST_SUPPLIERS: Database connection closed.")

@app.route('/api/suppliers/<int:supplier_id>', methods=['GET'])
def get_supplier(supplier_id):
    print(f"Received request for GET /api/suppliers/{supplier_id}")
    if engine is None: return jsonify({"error": "Database engine not initialized."}), 500
    conn = None
    try:
        conn = engine.connect()
        query = text("SELECT * FROM suppliers WHERE id = :id")
        result = conn.execute(query, {"id": supplier_id}).fetchone()
        if result is None: return jsonify({"error": f"Supplier with ID {supplier_id} not found."}), 404
        supplier_raw = convert_row_to_dict(result)
        supplier_json_safe = supplier_raw.copy()
        for key, value in supplier_json_safe.items():
             if isinstance(value, datetime):
                  supplier_json_safe[key] = value.isoformat()
             elif isinstance(value, Decimal): # Added Decimal check
                 supplier_json_safe[key] = str(value)
        print(f"DEBUG GET_SUPPLIER: Found supplier ID: {supplier_id}.")
        return jsonify(supplier_json_safe)
    except Exception as e:
        print(f"ERROR GET_SUPPLIER: {e}"); traceback.print_exc()
        return jsonify({"error": "Failed to fetch supplier", "details": str(e)}), 500
    finally:
        if conn and not conn.closed: conn.close()
        print(f"DEBUG GET_SUPPLIER: Database connection closed for ID {supplier_id}.")

@app.route('/api/suppliers/<int:supplier_id>', methods=['PUT'])
def update_supplier(supplier_id):
    print(f"Received request for PUT /api/suppliers/{supplier_id}")
    if engine is None: return jsonify({"error": "Database engine not initialized."}), 500
    conn = None; trans = None
    try:
        supplier_data = request.json
        if not supplier_data: return jsonify({"error": "No update data provided."}), 400
        conn = engine.connect(); trans = conn.begin()
        exists_query = text("SELECT id FROM suppliers WHERE id = :id")
        if not conn.execute(exists_query, {"id": supplier_id}).fetchone():
            trans.rollback(); return jsonify({"error": f"Supplier with ID {supplier_id} not found."}), 404
        allowed_fields = ['name', 'email', 'payment_terms', 'address_line1', 'address_line2','city', 'state', 'zip', 'country', 'phone', 'contact_person']
        update_parts = []; update_params = {"id": supplier_id, "now": datetime.now(timezone.utc)}
        for field in allowed_fields:
            if field in supplier_data: update_parts.append(f"{field} = :{field}"); update_params[field] = supplier_data[field]
        if not update_parts: trans.rollback(); return jsonify({"error": "No valid fields provided for update."}), 400
        update_sql_str = f"UPDATE suppliers SET {', '.join(update_parts)}, updated_at = :now WHERE id = :id"
        conn.execute(text(update_sql_str), update_params); trans.commit()
        print(f"DEBUG UPDATE_SUPPLIER: Updated supplier ID: {supplier_id}")
        return jsonify({"message": f"Supplier with ID {supplier_id} updated successfully."}), 200
    except sqlalchemy.exc.IntegrityError as e:
        if trans and trans.is_active: trans.rollback()
        print(f"ERROR UPDATE_SUPPLIER: Integrity Error: {e}")
        return jsonify({"error": "Update failed: Duplicate entry."}), 409
    except Exception as e:
        if trans and trans.is_active: trans.rollback()
        print(f"ERROR UPDATE_SUPPLIER: Unexpected error: {e}"); traceback.print_exc()
        return jsonify({"error": "Supplier update failed.", "details": str(e)}), 500
    finally:
        if conn and not conn.closed: conn.close()
        print(f"DEBUG UPDATE_SUPPLIER: Database connection closed for ID {supplier_id}.")

@app.route('/api/suppliers/<int:supplier_id>', methods=['DELETE'])
def delete_supplier(supplier_id):
    print(f"Received request for DELETE /api/suppliers/{supplier_id}")
    if engine is None: return jsonify({"error": "Database engine not initialized."}), 500
    conn = None; trans = None
    try:
        conn = engine.connect(); trans = conn.begin()
        delete_sql = text("DELETE FROM suppliers WHERE id = :id")
        result = conn.execute(delete_sql, {"id": supplier_id})
        if result.rowcount == 0: trans.rollback(); return jsonify({"error": f"Supplier with ID {supplier_id} not found."}), 404
        trans.commit()
        print(f"DEBUG DELETE_SUPPLIER: Deleted supplier ID: {supplier_id}")
        return jsonify({"message": f"Supplier with ID {supplier_id} deleted successfully."}), 200
    except Exception as e:
        if trans and trans.is_active: trans.rollback()
        print(f"ERROR DELETE_SUPPLIER: {e}"); traceback.print_exc()
        # Consider FK constraints - deleting might fail if POs reference this supplier
        return jsonify({"error": "Supplier deletion failed.", "details": str(e)}), 500
    finally:
        if conn and not conn.closed: conn.close()
        print(f"DEBUG DELETE_SUPPLIER: Database connection closed for ID {supplier_id}.")


# === PRODUCT MAPPING CRUD ROUTES ===
# (Assuming these are correct as provided)
@app.route('/api/products', methods=['POST'])
def create_product_mapping():
    print("Received request for POST /api/products")
    if engine is None: return jsonify({"error": "Database engine not initialized."}), 500
    conn = None; trans = None
    try:
        product_data = request.json
        if not product_data or not product_data.get('sku') or not product_data.get('standard_description'):
            return jsonify({"error": "Missing required fields: sku and standard_description"}), 400
        conn = engine.connect(); trans = conn.begin()
        insert_sql = text("INSERT INTO products (sku, standard_description, created_at, updated_at) VALUES (:sku, :desc, :now, :now) RETURNING id")
        params = {"sku": product_data.get('sku'), "desc": product_data.get('standard_description'), "now": datetime.now(timezone.utc)}
        result = conn.execute(insert_sql, params)
        inserted_product_id = result.scalar_one_or_none()
        if inserted_product_id is None: raise Exception("Failed to get new product ID.")
        trans.commit()
        print(f"DEBUG CREATE_PRODUCT: Inserted product mapping ID: {inserted_product_id}")
        return jsonify({"message": "Product mapping created successfully", "product_id": inserted_product_id}), 201
    except sqlalchemy.exc.IntegrityError as e:
        if trans and trans.is_active: trans.rollback()
        print(f"ERROR CREATE_PRODUCT: Integrity Error: {e}")
        return jsonify({"error": "Product mapping creation failed: Duplicate SKU exists."}), 409
    except Exception as e:
        if trans and trans.is_active: trans.rollback()
        print(f"ERROR CREATE_PRODUCT: Unexpected error: {e}"); traceback.print_exc()
        return jsonify({"error": "Product mapping creation failed.", "details": str(e)}), 500
    finally:
        if conn and not conn.closed: conn.close()
        print("DEBUG CREATE_PRODUCT: Database connection closed.")

@app.route('/api/products', methods=['GET'])
def list_product_mappings():
    print("Received request for GET /api/products")
    if engine is None: return jsonify({"error": "Database engine not initialized."}), 500
    conn = None
    try:
        conn = engine.connect()
        sku_filter = request.args.get('sku')
        query_sql_str = "SELECT * FROM products"
        params = {}
        if sku_filter: query_sql_str += " WHERE sku = :sku"; params["sku"] = sku_filter
        query_sql_str += " ORDER BY sku"
        query = text(query_sql_str)
        result = conn.execute(query, params)
        products_raw = [convert_row_to_dict(row) for row in result]
        products_json_safe = []
        for product in products_raw:
             product_json = product.copy() # Work on a copy
             for key, value in product_json.items():
                  if isinstance(value, datetime):
                       product_json[key] = value.isoformat()
                  elif isinstance(value, Decimal): # Added Decimal check
                       product_json[key] = str(value)
             products_json_safe.append(product_json)
        print(f"DEBUG LIST_PRODUCTS: Found {len(products_json_safe)} product mappings.")
        return jsonify(products_json_safe)
    except Exception as e:
        print(f"ERROR LIST_PRODUCTS: {e}"); traceback.print_exc()
        return jsonify({"error": "Failed to fetch product mappings", "details": str(e)}), 500
    finally:
        if conn and not conn.closed: conn.close()
        print("DEBUG LIST_PRODUCTS: Database connection closed.")

@app.route('/api/products/<int:product_id>', methods=['GET'])
def get_product_mapping(product_id):
    print(f"Received request for GET /api/products/{product_id}")
    if engine is None: return jsonify({"error": "Database engine not initialized."}), 500
    conn = None
    try:
        conn = engine.connect()
        query = text("SELECT * FROM products WHERE id = :id")
        result = conn.execute(query, {"id": product_id}).fetchone()
        if result is None: return jsonify({"error": f"Product mapping with ID {product_id} not found."}), 404
        product_raw = convert_row_to_dict(result)
        product_json_safe = product_raw.copy()
        for key, value in product_json_safe.items():
             if isinstance(value, datetime):
                  product_json_safe[key] = value.isoformat()
             elif isinstance(value, Decimal): # Added Decimal check
                 product_json_safe[key] = str(value)
        print(f"DEBUG GET_PRODUCT: Found product mapping ID: {product_id}.")
        return jsonify(product_json_safe)
    except Exception as e:
        print(f"ERROR GET_PRODUCT: {e}"); traceback.print_exc()
        return jsonify({"error": "Failed to fetch product mapping", "details": str(e)}), 500
    finally:
        if conn and not conn.closed: conn.close()
        print(f"DEBUG GET_PRODUCT: Database connection closed for ID {product_id}.")

@app.route('/api/products/<int:product_id>', methods=['PUT'])
def update_product_mapping(product_id):
    print(f"Received request for PUT /api/products/{product_id}")
    if engine is None: return jsonify({"error": "Database engine not initialized."}), 500
    conn = None; trans = None
    try:
        product_data = request.json
        if not product_data: return jsonify({"error": "No update data provided."}), 400
        conn = engine.connect(); trans = conn.begin()
        exists_query = text("SELECT id FROM products WHERE id = :id")
        if not conn.execute(exists_query, {"id": product_id}).fetchone():
            trans.rollback(); return jsonify({"error": f"Product mapping with ID {product_id} not found."}), 404
        allowed_fields = ['sku', 'standard_description']
        update_parts = []; update_params = {"id": product_id, "now": datetime.now(timezone.utc)}
        for field in allowed_fields:
            if field in product_data: update_parts.append(f"{field} = :{field}"); update_params[field] = product_data[field]
        if not update_parts: trans.rollback(); return jsonify({"error": "No valid fields provided for update."}), 400
        update_sql_str = f"UPDATE products SET {', '.join(update_parts)}, updated_at = :now WHERE id = :id"
        conn.execute(text(update_sql_str), update_params); trans.commit()
        print(f"DEBUG UPDATE_PRODUCT: Updated product mapping ID: {product_id}")
        return jsonify({"message": f"Product mapping with ID {product_id} updated successfully."}), 200
    except sqlalchemy.exc.IntegrityError as e:
        if trans and trans.is_active: trans.rollback()
        print(f"ERROR UPDATE_PRODUCT: Integrity Error: {e}")
        return jsonify({"error": "Update failed: Duplicate SKU exists."}), 409
    except Exception as e:
        if trans and trans.is_active: trans.rollback()
        print(f"ERROR UPDATE_PRODUCT: Unexpected error: {e}"); traceback.print_exc()
        return jsonify({"error": "Product mapping update failed.", "details": str(e)}), 500
    finally:
        if conn and not conn.closed: conn.close()
        print(f"DEBUG UPDATE_PRODUCT: Database connection closed for ID {product_id}.")

@app.route('/api/products/<int:product_id>', methods=['DELETE'])
def delete_product_mapping(product_id):
    print(f"Received request for DELETE /api/products/{product_id}")
    if engine is None: return jsonify({"error": "Database engine not initialized."}), 500
    conn = None; trans = None
    try:
        conn = engine.connect(); trans = conn.begin()
        delete_sql = text("DELETE FROM products WHERE id = :id")
        result = conn.execute(delete_sql, {"id": product_id})
        if result.rowcount == 0: trans.rollback(); return jsonify({"error": f"Product mapping with ID {product_id} not found."}), 404
        trans.commit()
        print(f"DEBUG DELETE_PRODUCT: Deleted product mapping ID: {product_id}")
        return jsonify({"message": f"Product mapping with ID {product_id} deleted successfully."}), 200
    except Exception as e:
        if trans and trans.is_active: trans.rollback()
        print(f"ERROR DELETE_PRODUCT: {e}"); traceback.print_exc()
        return jsonify({"error": "Product mapping deletion failed.", "details": str(e)}), 500
    finally:
        if conn and not conn.closed: conn.close()
        print(f"DEBUG DELETE_PRODUCT: Database connection closed for ID {product_id}.")


# === PROCESS ORDER ROUTE ===
@app.route('/api/orders/<int:order_id>/process', methods=['POST'])
def process_order(order_id):
    """Orchestrates the drop-shipment process for a given domestic order."""
    print(f"DEBUG PROCESS_ORDER: Received request to process order ID: {order_id}")
    db_conn = None
    transaction = None
    po_pdf_bytes = None
    packing_slip_pdf_bytes = None
    generated_po_number = None
    new_purchase_order_id = None
    order_data_dict = None
    supplier_data_dict = None
    po_line_items_input = None
    total_shipment_weight_lbs = None

    try:
        # 1. Receive and Validate Input Data
        data = request.get_json()
        if not data: return jsonify({"error": "Invalid or missing JSON payload"}), 400

        supplier_id = data.get('supplier_id')
        po_line_items_input = data.get('po_line_items')
        total_shipment_weight_lbs = data.get('total_shipment_weight_lbs')
        payment_instructions = data.get('payment_instructions', "")

        required_fields_err = []
        if not supplier_id: required_fields_err.append("supplier_id")
        if not po_line_items_input: required_fields_err.append("po_line_items")
        if total_shipment_weight_lbs is None: required_fields_err.append("total_shipment_weight_lbs")
        if required_fields_err: return jsonify({"error": f"Missing required fields: {', '.join(required_fields_err)}"}), 400
        if not isinstance(po_line_items_input, list) or not po_line_items_input: return jsonify({"error": "'po_line_items' must be a non-empty list"}), 400
        for item in po_line_items_input:
            if not all(k in item for k in ("sku", "quantity", "unit_cost")): return jsonify({"error": "Each PO line item must contain 'sku', 'quantity', 'unit_cost'"}), 400
        try: total_shipment_weight_lbs = float(total_shipment_weight_lbs)
        except (ValueError, TypeError): return jsonify({"error": "'total_shipment_weight_lbs' must be a valid number."}), 400
        print(f"DEBUG PROCESS_ORDER: Input validated: Supplier ID={supplier_id}, Weight={total_shipment_weight_lbs} lbs")

        # 2. Database Connection & Transaction
        if engine is None: return jsonify({"error": "Database engine not available."}), 500
        db_conn = engine.connect()
        transaction = db_conn.begin()
        print("DEBUG PROCESS_ORDER: DB connection and transaction started.")

        # 3. Fetch Required Data from Local DB
        order_record = db_conn.execute(text("SELECT * FROM orders WHERE id = :id"), {"id": order_id}).fetchone()
        if not order_record: raise ValueError(f"Order with ID {order_id} not found in local DB.")
        order_data_dict = convert_row_to_dict(order_record) # Use helper

        local_order_line_items_records = db_conn.execute(text("SELECT * FROM order_line_items WHERE order_id = :id ORDER BY id"), {"id": order_id}).fetchall()
        local_order_line_items_list = [convert_row_to_dict(row) for row in local_order_line_items_records] # Use helper

        supplier_record = db_conn.execute(text("SELECT * FROM suppliers WHERE id = :id"), {"id": supplier_id}).fetchone()
        if not supplier_record: raise ValueError(f"Supplier with ID {supplier_id} not found.")
        supplier_data_dict = convert_row_to_dict(supplier_record) # Use helper
        print(f"DEBUG PROCESS_ORDER: Fetched Order ID={order_data_dict['id']}, Supplier={supplier_data_dict['name']}")

        # 4. Check if Order is Domestic
        if order_data_dict.get('is_international'):
             raise ValueError(f"Order {order_id} is international and requires manual processing.")

        # 5. Generate PO Number
        starting_po_sequence = 200001
        max_po_value_from_db = db_conn.execute(text("SELECT MAX(po_number) FROM purchase_orders")).scalar_one_or_none()
        if max_po_value_from_db is None: next_sequence_num = starting_po_sequence
        else:
            try:
                current_max_po = int(max_po_value_from_db)
                next_sequence_num = starting_po_sequence if current_max_po < starting_po_sequence else current_max_po + 1
            except (ValueError, TypeError): next_sequence_num = starting_po_sequence
        generated_po_number = next_sequence_num
        print(f"DEBUG PROCESS_ORDER: Generated PO Number: {generated_po_number}")

        # 6. Insert Purchase Order Record
        current_utc_datetime = datetime.now(timezone.utc) # Keep datetime object
        po_total_amount = sum(Decimal(item.get('quantity', 0)) * Decimal(item.get('unit_cost', 0)) for item in po_line_items_input)
        insert_po_sql = text("""INSERT INTO purchase_orders (po_number, order_id, supplier_id, po_date, payment_instructions, status, total_amount) VALUES (:po_number, :order_id, :supplier_id, :po_date, :payment_instructions, :status, :total_amount) RETURNING id""")
        po_params = {"po_number": generated_po_number, "order_id": order_id, "supplier_id": supplier_id, "po_date": current_utc_datetime, "payment_instructions": payment_instructions, "status": "New", "total_amount": po_total_amount}
        result_po_insert = db_conn.execute(insert_po_sql, po_params)
        new_purchase_order_id = result_po_insert.scalar_one_or_none()
        if new_purchase_order_id is None: raise Exception("Failed to get new purchase_order_id.")
        print(f"DEBUG PROCESS_ORDER: Inserted purchase_orders record. DB ID: {new_purchase_order_id}")

        # 7. Insert Purchase Order Line Items
        insert_po_item_sql = text("""INSERT INTO po_line_items (purchase_order_id, original_order_line_item_id, sku, description, quantity, unit_cost, condition) VALUES (:po_id, :orig_id, :sku, :desc, :qty, :cost, :cond)""")
        items_inserted_count = 0
        for item_input in po_line_items_input:
            item_description = f"Sourced: {item_input.get('sku')}" # Placeholder
            orig_id = item_input.get("original_order_line_item_id")
            original_item_detail = next((oli for oli in local_order_line_items_list if oli.get('id') == orig_id), None)
            if original_item_detail: item_description = original_item_detail.get('name', item_description)
            po_item_params = {"po_id": new_purchase_order_id, "orig_id": orig_id, "sku": item_input.get("sku"), "desc": item_description, "qty": item_input.get("quantity"), "cost": Decimal(item_input.get("unit_cost")), "cond": item_input.get("condition", "New")}
            db_conn.execute(insert_po_item_sql, po_item_params)
            items_inserted_count += 1
        print(f"DEBUG PROCESS_ORDER: Inserted {items_inserted_count} po_line_items records.")

        # 8. Generate Documents
        print("DEBUG PROCESS_ORDER: Generating documents...")
        if document_generator is None: raise ModuleNotFoundError("document_generator module not loaded.")

        # --- Prepare PO data args - **KEYS MUST MATCH FUNCTION PARAMETER NAMES** ---
        po_pdf_data_args = {
            "supplier_data": supplier_data_dict,
            "po_number": str(generated_po_number),
            "po_date": current_utc_datetime, # Pass the datetime object directly
            "po_items": po_line_items_input,
            "payment_terms": supplier_data_dict.get('payment_terms'),
            "payment_instructions": payment_instructions,
            "order_data": order_data_dict
        }

        try:
            # Call PO PDF generation passing arguments using **kwargs
            print(f"DEBUG PROCESS_ORDER: Calling generate_purchase_order_pdf with keys: {list(po_pdf_data_args.keys())}")
            po_pdf_bytes = document_generator.generate_purchase_order_pdf(**po_pdf_data_args)
            if not po_pdf_bytes or not isinstance(po_pdf_bytes, bytes): raise ValueError("generate_purchase_order_pdf did not return valid bytes.")
            print(f"DEBUG PROCESS_ORDER: Purchase Order PDF generated ({len(po_pdf_bytes)} bytes).")
        except TypeError as type_err:
             print(f"ERROR PROCESS_ORDER: TypeError calling generate_purchase_order_pdf: {type_err}")
             print(f"Ensure the function definition in document_generator.py matches the arguments being passed: {list(po_pdf_data_args.keys())}")
             raise
        except Exception as pdf_po_e:
             print(f"ERROR PROCESS_ORDER: Failed to generate Purchase Order PDF: {pdf_po_e}")
             raise Exception(f"PO PDF generation failed: {pdf_po_e}") from pdf_po_e

        # --- Prepare Packing Slip data args - **KEYS MUST MATCH FUNCTION PARAMETER NAMES** ---
        # Based on errors, removed: purchase_order_number, order_id, order_date, items
        # Based on last error, it expects 'packing_slip_items'
        packing_slip_data_args = {
            "order_data": order_data_dict,
            "packing_slip_items": local_order_line_items_list # Use correct key name
            # Add any other arguments that ARE expected by generate_packing_slip_pdf
        }

        try:
            # Call Packing Slip PDF generation
            print(f"DEBUG PROCESS_ORDER: Calling generate_packing_slip_pdf with keys: {list(packing_slip_data_args.keys())}")
            packing_slip_pdf_bytes = document_generator.generate_packing_slip_pdf(**packing_slip_data_args)
            if not packing_slip_pdf_bytes or not isinstance(packing_slip_pdf_bytes, bytes): raise ValueError("generate_packing_slip_pdf did not return valid bytes.")
            print(f"DEBUG PROCESS_ORDER: Packing Slip PDF generated ({len(packing_slip_pdf_bytes)} bytes).")
        except TypeError as type_err:
             print(f"ERROR PROCESS_ORDER: TypeError calling generate_packing_slip_pdf: {type_err}")
             print(f"Ensure the function definition in document_generator.py matches the arguments being passed: {list(packing_slip_data_args.keys())}")
             raise
        except Exception as pdf_ps_e:
            print(f"ERROR PROCESS_ORDER: Failed to generate Packing Slip PDF: {pdf_ps_e}")
            raise Exception(f"Packing Slip PDF generation failed: {pdf_ps_e}") from pdf_ps_e


        # --- TODO: Placeholder for next steps ---
        # 9. UPS Label Generation -> tracking_num, label_pdf_bytes
        # 10. Database Writes (INSERT into shipments table)
        # 11. Google Cloud Storage (Save PDFs) -> Store GCS paths in DB
        # 12. Email Documents to Supplier
        # 13. Update BigCommerce
        # 14. Update Local Order Status
        # --- END TODO ---
        print("DEBUG PROCESS_ORDER: Placeholder for UPS, GCS, Email, BC Update, Local Status Update...")

        transaction.commit()
        print(f"DEBUG PROCESS_ORDER: Transaction committed for order {order_id} (PO created, Docs generated).")

        return jsonify({
            "message": f"Purchase Order {generated_po_number} created and documents generated successfully for order {order_id}. Further processing pending.",
            "order_id": order_data_dict.get('id'),
            "purchase_order_db_id": new_purchase_order_id,
            "purchase_order_number": generated_po_number,
            "po_pdf_size_bytes": len(po_pdf_bytes) if po_pdf_bytes else 0,
            "packing_slip_pdf_size_bytes": len(packing_slip_pdf_bytes) if packing_slip_pdf_bytes else 0
        }), 201

    except ValueError as ve: # Catch specific validation errors first
        if transaction and transaction.is_active: transaction.rollback()
        print(f"ERROR PROCESS_ORDER: Validation Error: {ve}")
        return jsonify({"error": "Processing failed due to invalid data or state.", "details": str(ve)}), 400
    except ModuleNotFoundError as me: # Catch missing service modules
         if transaction and transaction.is_active: transaction.rollback()
         print(f"ERROR PROCESS_ORDER: Missing Module Error: {me}")
         return jsonify({"error": "Processing failed due to missing internal module.", "details": str(me)}), 500
    except Exception as e: # Catch all other exceptions
        if transaction and transaction.is_active:
             try: transaction.rollback()
             except Exception as rb_e: print(f"ERROR PROCESS_ORDER: Error during transaction rollback: {rb_e}")
        else: print(f"DEBUG PROCESS_ORDER: Cannot rollback transaction (or not needed). Error: {e}")
        original_error_traceback = traceback.format_exc()
        print("--- ORIGINAL ERROR TRACEBACK ---"); print(original_error_traceback); print("--- END ---")
        return jsonify({"error": "An unexpected error occurred during order processing.", "details": str(e)}), 500
    finally:
        if db_conn:
            if not db_conn.closed: db_conn.close()
            print(f"DEBUG PROCESS_ORDER: Database connection closed for order {order_id}.")


# === Entry point for running the Flask app ===
if __name__ == '__main__':
    print(f"Starting G1 PO App Backend...")
    if engine is None:
        print("CRITICAL MAIN: Database engine not initialized. Flask app might not work correctly with DB operations.")
    else:
        run_host = os.getenv("FLASK_RUN_HOST", "127.0.0.1")
        run_port = int(os.getenv("FLASK_RUN_PORT", 8080))
        print(f"--> Running Flask app on {run_host}:{run_port} with debug={app.debug}")
        # Use debug=app.debug which is set from FLASK_DEBUG env var
        app.run(host=run_host, port=run_port, debug=app.debug)

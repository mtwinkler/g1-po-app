# backend/app/blueprints/customs_info_crud.py
import traceback
from flask import Blueprint, jsonify, request, g, current_app
import sqlalchemy
from sqlalchemy import text
from sqlalchemy.dialects.postgresql import insert # For potential future "upsert" needs

# Imports from the main app.py
from app import engine, verify_firebase_token, convert_row_to_dict, make_json_safe

customs_info_bp = Blueprint('customs_info_bp', __name__)

BASE_TABLE_NAME = 'customs_info'

# --- CREATE ---
@customs_info_bp.route('/customs-info', methods=['POST'])
@verify_firebase_token
def create_customs_info_entry():
    print(f"Received request for POST /api/customs-info")
    if engine is None:
        return jsonify({"message": "Database engine not initialized."}), 500

    conn = None
    trans = None
    try:
        data = request.json
        print(f"DEBUG CREATE_CUSTOMS_INFO: Received data: {data}")

        required_fields = ['product_type', 'customs_description', 'harmonized_tariff_code', 'default_country_of_origin']
        for field in required_fields:
            if field not in data or not data[field]: # Also check for empty strings if they are not allowed
                print(f"DEBUG CREATE_CUSTOMS_INFO: Missing or empty required field: {field}")
                return jsonify({"message": f"Missing or empty required field: {field}"}), 400

        conn = engine.connect()
        trans = conn.begin()

        # Using sqlalchemy.table and column for dynamic query building
        # Note: 'id' is auto-generated by the database (SERIAL or IDENTITY)
        customs_table = sqlalchemy.table(BASE_TABLE_NAME,
                                       sqlalchemy.column('product_type'),
                                       sqlalchemy.column('customs_description'),
                                       sqlalchemy.column('harmonized_tariff_code'),
                                       sqlalchemy.column('default_country_of_origin'))

        insert_stmt = insert(customs_table).values(
            product_type=data.get('product_type'),
            customs_description=data.get('customs_description'),
            harmonized_tariff_code=data.get('harmonized_tariff_code'),
            default_country_of_origin=data.get('default_country_of_origin')
        ).returning(sqlalchemy.column('id'), # Return the generated ID
                    sqlalchemy.column('product_type'),
                    sqlalchemy.column('customs_description'),
                    sqlalchemy.column('harmonized_tariff_code'),
                    sqlalchemy.column('default_country_of_origin'))

        result = conn.execute(insert_stmt)
        new_entry_row = result.fetchone()
        trans.commit()

        new_entry_dict = convert_row_to_dict(new_entry_row)
        print(f"DEBUG CREATE_CUSTOMS_INFO: Inserted Customs Info. ID: {new_entry_dict.get('id')}")
        return jsonify({"message": "Customs Information entry created successfully", "data": make_json_safe(new_entry_dict)}), 201

    except sqlalchemy.exc.IntegrityError as e: # Example: if you add unique constraints later
        if conn and trans and trans.is_active: trans.rollback()
        print(f"DEBUG CREATE_CUSTOMS_INFO: Integrity Error: {e}")
        # Customize error based on actual constraints if any (e.g., a unique constraint on product_type)
        # For now, a generic integrity error.
        return jsonify({"message": f"Database integrity error: {e.orig}", "error_type": "IntegrityError"}), 409
    except Exception as e:
        if conn and trans and trans.is_active: trans.rollback()
        print(f"DEBUG CREATE_CUSTOMS_INFO: Unexpected exception: {e}")
        traceback.print_exc()
        return jsonify({"message": f"Customs Information entry creation failed: {str(e)}", "error_type": type(e).__name__}), 500
    finally:
        if conn and not conn.closed: conn.close(); print("DEBUG CREATE_CUSTOMS_INFO: DB connection closed.")

# --- READ (List with Pagination and Filtering) ---
@customs_info_bp.route('/customs-info', methods=['GET'])
@verify_firebase_token
def list_customs_info_entries():
    print("Received request for GET /api/customs-info")
    if engine is None:
        return jsonify({"error": "Database engine not initialized."}), 500

    conn = None
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 25, type=int)
        if page < 1: page = 1
        if per_page < 1: per_page = 1
        if per_page > 100: per_page = 100 # Max limit
        offset = (page - 1) * per_page

        # Filtering examples (add more as needed)
        filter_product_type = request.args.get('filter_product_type', None, type=str)
        filter_customs_description = request.args.get('filter_customs_description', None, type=str)

        base_query_fields = "SELECT id, product_type, customs_description, harmonized_tariff_code, default_country_of_origin FROM " + BASE_TABLE_NAME
        count_query_fields = "SELECT COUNT(*) FROM " + BASE_TABLE_NAME
        where_clauses = []
        query_params = {}

        if filter_product_type and filter_product_type.strip():
            where_clauses.append("product_type ILIKE :filter_pt_param")
            query_params["filter_pt_param"] = f"%{filter_product_type.strip()}%"
        
        if filter_customs_description and filter_customs_description.strip():
            where_clauses.append("customs_description ILIKE :filter_cd_param")
            query_params["filter_cd_param"] = f"%{filter_customs_description.strip()}%"
        
        where_sql = ""
        if where_clauses:
            where_sql = " WHERE " + " AND ".join(where_clauses)

        pagination_query_params = {"limit_param": per_page, "offset_param": offset}
        # Order by id or product_type, for example
        data_sql_str = f"{base_query_fields}{where_sql} ORDER BY product_type, id LIMIT :limit_param OFFSET :offset_param"
        final_data_query_params = {**query_params, **pagination_query_params}
        data_query = text(data_sql_str)

        count_sql_str = f"{count_query_fields}{where_sql}"
        count_query = text(count_sql_str)

        conn = engine.connect()
        result = conn.execute(data_query, final_data_query_params)
        entries_list = [convert_row_to_dict(row) for row in result]
        
        total_count_result = conn.execute(count_query, query_params).scalar_one_or_none()
        total_items = total_count_result if total_count_result is not None else 0
        total_pages = (total_items + per_page - 1) // per_page if per_page > 0 else 0

        return jsonify({
            "entries": make_json_safe(entries_list),
            "pagination": {
                "currentPage": page, "perPage": per_page,
                "totalItems": total_items, "totalPages": total_pages
            }
        }), 200
    except Exception as e:
        print(f"ERROR LIST_CUSTOMS_INFO: Unexpected exception: {e}")
        traceback.print_exc()
        return jsonify({"error": f"Error fetching customs info entries: {str(e)}", "error_type": type(e).__name__}), 500
    finally:
        if conn and not conn.closed:
            conn.close()
            print("DEBUG LIST_CUSTOMS_INFO: DB connection closed.")

# --- READ (Single Entry by ID) ---
@customs_info_bp.route('/customs-info/<int:item_id>', methods=['GET'])
@verify_firebase_token
def get_customs_info_entry(item_id):
    print(f"Received request for GET /api/customs-info/{item_id}")
    if engine is None: return jsonify({"message": "Database engine not initialized."}), 500
    conn = None
    try:
        conn = engine.connect()
        query_str = "SELECT id, product_type, customs_description, harmonized_tariff_code, default_country_of_origin FROM " + \
                    BASE_TABLE_NAME + " WHERE id = :item_id_param"
        query = text(query_str)
        result = conn.execute(query, {"item_id_param": item_id}).fetchone()
        
        if result is None:
            print(f"DEBUG GET_CUSTOMS_INFO: Entry with ID '{item_id}' not found.")
            return jsonify({"message": f"Customs Information entry with ID '{item_id}' not found."}), 404
        
        entry_dict = convert_row_to_dict(result)
        print(f"DEBUG GET_CUSTOMS_INFO: Found entry for ID: {item_id}.")
        return jsonify(make_json_safe(entry_dict)), 200
    except Exception as e:
        print(f"DEBUG GET_CUSTOMS_INFO: Unexpected exception for ID {item_id}: {e}")
        traceback.print_exc()
        return jsonify({"message": f"Error fetching customs info entry: {e}", "error_type": type(e).__name__}), 500
    finally:
        if conn and not conn.closed: conn.close(); print(f"DEBUG GET_CUSTOMS_INFO: DB conn closed for ID {item_id}.")

# --- UPDATE ---
@customs_info_bp.route('/customs-info/<int:item_id>', methods=['PUT'])
@verify_firebase_token
def update_customs_info_entry(item_id):
    print(f"Received request for PUT /api/customs-info/{item_id}")
    if engine is None: return jsonify({"message": "Database engine not initialized."}), 500
    conn, trans = None, None
    try:
        data = request.json
        print(f"DEBUG UPDATE_CUSTOMS_INFO: Data for ID {item_id}: {data}")
        
        # Ensure at least one field is provided for update (or handle as needed)
        # For this example, we'll update all provided fields.
        # You might want to check if data is empty.

        conn = engine.connect(); trans = conn.begin()
        
        check_sql_str = "SELECT 1 FROM " + BASE_TABLE_NAME + " WHERE id = :item_id_param"
        check_sql = text(check_sql_str)
        exists = conn.execute(check_sql, {"item_id_param": item_id}).fetchone()
        if not exists:
            trans.rollback(); print(f"DEBUG UPDATE_CUSTOMS_INFO: Entry with ID {item_id} not found.")
            return jsonify({"message": f"Customs Information entry with ID {item_id} not found."}), 404
        
        # Construct SET clauses dynamically based on provided data
        set_clauses = []
        update_params = {"item_id_param": item_id}
        allowed_fields_to_update = ['product_type', 'customs_description', 'harmonized_tariff_code', 'default_country_of_origin']
        
        for field in allowed_fields_to_update:
            if field in data: # Update if field is present in payload
                set_clauses.append(f"{field} = :{field}_param")
                update_params[f"{field}_param"] = data[field]

        if not set_clauses:
             trans.rollback() # Or just don't commit if no changes
             return jsonify({"message": "No valid fields provided for update."}), 400

        update_sql_str = f"UPDATE {BASE_TABLE_NAME} SET {', '.join(set_clauses)} WHERE id = :item_id_param"
        update_sql = text(update_sql_str)
        result = conn.execute(update_sql, update_params)
        
        if result.rowcount == 0: 
            # This might happen if the data sent is the same as existing data,
            # or if the ID was found but somehow not updated.
            trans.rollback() # Or commit if "no change" is acceptable
            print(f"DEBUG UPDATE_CUSTOMS_INFO: Entry with ID {item_id} found but not updated (no change or error).")
            return jsonify({"message": f"Entry with ID {item_id} found but not updated (no change or error)."}), 404 # Or 200 if no change is OK.

        trans.commit(); print(f"DEBUG UPDATE_CUSTOMS_INFO: Updated entry for ID: {item_id}")
        # Optionally, fetch and return the updated record
        # For now, just a success message.
        return jsonify({"message": f"Customs Information entry for ID {item_id} updated successfully"}), 200
    except Exception as e:
        if conn and trans and trans.is_active: trans.rollback()
        print(f"DEBUG UPDATE_CUSTOMS_INFO: Unexpected exception for ID {item_id}: {e}")
        traceback.print_exc()
        return jsonify({"message": f"Customs Information entry update failed: {e}", "error_type": type(e).__name__}), 500
    finally:
        if conn and not conn.closed: conn.close(); print(f"DEBUG UPDATE_CUSTOMS_INFO: DB conn closed for ID {item_id}.")

# --- DELETE ---
@customs_info_bp.route('/customs-info/<int:item_id>', methods=['DELETE'])
@verify_firebase_token
def delete_customs_info_entry(item_id):
    print(f"Received request for DELETE /api/customs-info/{item_id}")
    if engine is None: return jsonify({"message": "Database engine not initialized."}), 500
    conn, trans = None, None
    try:
        conn = engine.connect(); trans = conn.begin()
        delete_sql_str = "DELETE FROM " + BASE_TABLE_NAME + " WHERE id = :item_id_param"
        delete_sql = text(delete_sql_str)
        result = conn.execute(delete_sql, {"item_id_param": item_id})
        
        if result.rowcount == 0:
            trans.rollback(); print(f"DEBUG DELETE_CUSTOMS_INFO: Entry with ID {item_id} not found.")
            return jsonify({"message": f"Customs Information entry with ID {item_id} not found."}), 404
        
        trans.commit(); print(f"DEBUG DELETE_CUSTOMS_INFO: Deleted entry for ID: {item_id}")
        return jsonify({"message": f"Customs Information entry for ID {item_id} deleted successfully"}), 200 # Or 204 No Content
    except Exception as e:
        if conn and trans and trans.is_active: trans.rollback()
        print(f"DEBUG DELETE_CUSTOMS_INFO: Unexpected exception for ID {item_id}: {e}")
        traceback.print_exc()
        return jsonify({"message": f"Customs Information entry deletion failed: {e}", "error_type": type(e).__name__}), 500
    finally:
        if conn and not conn.closed: conn.close(); print(f"DEBUG DELETE_CUSTOMS_INFO: DB conn closed for ID {item_id}.")